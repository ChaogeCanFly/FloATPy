import glob
import numpy

from base_reader import BaseReader

class WchrAsciiReader(BaseReader):
    """
    Class to read in parallel ASCII data generated by the WCHR Regent code.
    """
    
    def __init__(self, filename_prefix):
        """
        Constructor of the WCHR reader class.
        """
        
        self.filename_prefix = filename_prefix
        self.coord_files = glob.glob(filename_prefix + 'coords_*.dat')
        
        files = glob.glob(filename_prefix + '[0-9]*.dat')
        
        self._steps = steps = []
        self.prow  = 0
        self.pcol  = 0
        for f in files:
            step = int(f[len(filename_prefix):len(filename_prefix)+4])
            if not (step in steps):
                steps.append(step)
            
            st  = f[len(filename_prefix):]
            ind = st.find('px')
            row = int(st[ind+2:ind+6])
            if row > self.prow:
                self.prow = row
            ind = st.find('pz')
            col = int(st[ind+2:ind+6])
            if col > self.pcol:
                self.pcol = col
        
        self.prow += 1
        self.pcol += 1
        
        # Set the lowest and highest global index of processor in x and z directions respectively.
        
        self.pencil_lo    = numpy.zeros((self.prow,self.pcol,2), dtype=int)
        self.pencil_hi    = numpy.zeros((self.prow,self.pcol,2), dtype=int)
        
        # Set the domain size in x, y and z directions respectively.
        self._domain_size = numpy.zeros(3, dtype=int)  
        
        for row in range(self.prow):
            for col in range(self.pcol):
                coordfile = filename_prefix + ('coords_px%04d_pz%04d.dat' % (row, col))
                
                f = open(coordfile)
                
                line = f.readline().split()
                self.pencil_lo[row,col,0] = int(line[0])
                self.pencil_lo[row,col,1] = int(line[2])
                
                line = f.readline().split()
                self.pencil_hi[row,col,0] = int(line[0]) + 1
                self.pencil_hi[row,col,1] = int(line[2]) + 1
                
                if self._domain_size[1] == 0:
                    self._domain_size[1] = int(line[1]) + 1
                
                assert (self._domain_size[1] == (int(line[1]) + 1)), \
                    "Data is invalid. Unequal domain sized in the y direction for different pencils!"
                
                f.close()
        
        self._domain_size[0] = self.pencil_hi[-1,-1,0]
        self._domain_size[2] = self.pencil_hi[-1,-1,1]
        
        # Set indices for each variable.
        self.inds = {'rho' : 0, 'u' : 1, 'v' : 2, 'w' : 3, 'p' : 4}
        
        # Step is set to 0 by default.
        self._step = 0
        
        # Set subdomain to full domain by default
        self.chunk = ( (0, self._domain_size[0]), (0, self._domain_size[1]), (0, self._domain_size[2]) )
    
    
    def setStep(self, step):
        """
        Update the metadata from the summary file in the data directory at a new time step.
        """
        
        assert (step in self._steps), "Step to read in is not available in the dataset."
        self._step = step
    
    
    def getStep(self):
        return self._step
    
    
    step = property(getStep, setStep)
    
    
    def setSubDomain(self, lo_and_hi):
        """
        Set the sub-domain for reading coordinates and data.
        """
        
        # Check if lo and hi are within the domain bounds first!!!
        
        try:
            lo, hi = lo_and_hi
        except ValueError:
            raise ValueError("Pass an iterable with two items!")
        
        for i in range(3):
            if lo[i] < 0 or lo[i] > self._domain_size[i]:
                raise ValueError('Invalid indices in chunk. Cannot be < 0 or > domain size!')
            if hi[i] < 0 or hi[i] > self._domain_size[i]:
                raise ValueError('Invalid indices in chunk. Cannot be < 0 or > domain size!')
            if hi[i] < lo[i]:
                raise ValueError('Invalid indices in chunk. Upper bound cannot be smaller than lower bound!')
        
        # Now set the chunk to be used later.
        self.chunk = ( (lo[0], hi[0] + 1), (lo[1], hi[1] + 1), (lo[2], hi[2] + 1) )
    
    
    def getSubDomain(self):
        """
        Return two tuples containing the sub-domain used in this reader
        as a lower bound (lo) and upper bound (hi).
        """
        
        lo = (self.chunk[0][0], self.chunk[1][0], self.chunk[2][0])
        hi = (self.chunk[0][1] - 1, self.chunk[1][1] - 1, self.chunk[2][1] - 1)
        
        return lo, hi
    
    
    sub_domain = property(getSubDomain, setSubDomain)
    
    
    @property
    def domain_size(self):
        """
        Return a tuple containing the full domain size of this dataset.
        """
        
        return tuple(self._domain_size)
    
    
    @property
    def dimension(self):
        """
        Return the dimension of the domain.
        """
        
        return 3
    
    
    @property
    def periodic_dimensions(self):
        """
        Return a tuple indicating if data is periodic in each dimension.
        """
        
        return (True, True, True)
    
    
    @property
    def time(self):
        """
        Return the simulation time at current time step.
        """
        
        return 0.
    
    
    @property
    def data_order(self):
        """
        Return the data order.
        """
        
        return 'F'
    
    
    @property
    def steps(self):
        """
        Return all of the steps.
        """
        
        return self._steps
    
    
    def readCoordinatesInX(self):
        """
        Method to read in the full domain's coordinates in x direction.
        """
        
        self.x_c = numpy.zeros((self._domain_size[0], self._domain_size[1], self._domain_size[2] ))
        
        for row in range(self.prow):
            for col in range(self.pcol):
                coordfile = self.filename_prefix + ('coords_px%04d_pz%04d.dat' % (row, col))
                
                this_x = numpy.loadtxt(coordfile, skiprows=2, unpack=True, usecols=(0,))
                
                lo = self.pencil_lo[row,col]
                hi = self.pencil_hi[row,col]
                self.x_c[lo[0]:hi[0], :, lo[1]:hi[1]] = this_x.reshape((hi[0]-lo[0], self._domain_size[1], hi[1]-lo[1]), \
                                                                       order='F')
        
        if self._domain_size[0] > 1:
            self.dx = self.x_c[1,0,0] - self.x_c[0,0,0]
        else:
            self.dx = 1.
    
    
    def readCoordinatesInY(self):
        """
        Method to read in the full domain's coordinates in y direction.
        """
        
        self.y_c = numpy.zeros((self._domain_size[0], self._domain_size[1], self._domain_size[2] ))
        
        for row in range(self.prow):
            for col in range(self.pcol):
                coordfile = self.filename_prefix + ('coords_px%04d_pz%04d.dat' % (row, col))
                
                this_y = numpy.loadtxt(coordfile, skiprows=2, unpack=True, usecols=(1,))
                
                lo = self.pencil_lo[row,col]
                hi = self.pencil_hi[row,col]
                self.y_c[lo[0]:hi[0], :, lo[1]:hi[1]] = this_y.reshape((hi[0]-lo[0], self._domain_size[1], hi[1]-lo[1]), \
                                                                       order='F')
        
        if self._domain_size[1] > 1:
            self.dy = self.y_c[0,1,0] - self.y_c[0,0,0]
        else:
            self.dy = 1.
    
    
    def readCoordinatesInZ(self):
        """
        Method to read in the full domain's coordinates in z direction.
        """
        
        self.z_c = numpy.zeros((self._domain_size[0], self._domain_size[1], self._domain_size[2] ))

        for row in range(self.prow):
            for col in range(self.pcol):
                coordfile = self.filename_prefix + ('coords_px%04d_pz%04d.dat' % (row, col))

                this_z = numpy.loadtxt(coordfile, skiprows=2, unpack=True, usecols=(2,))

                lo = self.pencil_lo[row,col]
                hi = self.pencil_hi[row,col]
                self.z_c[lo[0]:hi[0], :, lo[1]:hi[1]] = this_z.reshape((hi[0]-lo[0], self._domain_size[1], hi[1]-lo[1]), \
                                                                       order='F')
        
        if self._domain_size[2] > 1:
            self.dz = self.z_c[0,0,1] - self.z_c[0,0,0]
        else:
            self.dz = 1.
    
    
    def readCoordinates(self):
        """
        Method to read in the X, Y and Z coordinates of a chunk of index values.
        """
        
        chunk_size = (self.chunk[0][1]-self.chunk[0][0], self.chunk[1][1]-self.chunk[1][0], self.chunk[2][1]-self.chunk[2][0])
        x_c = numpy.empty(chunk_size, order='F')
        y_c = numpy.empty(chunk_size, order='F')
        z_c = numpy.empty(chunk_size, order='F')
        
        ny = self._domain_size[1]
        
        for row in range(self.prow):
            for col in range(self.pcol):
                coordfile = self.filename_prefix + ('coords_px%04d_pz%04d.dat' % (row, col))
                lo = self.pencil_lo[row,col]
                hi = self.pencil_hi[row,col]
                
                # Skip this proc if it's lowest dimension is higher than max of chunk.
                
                if ( lo[0] >= self.chunk[0][1] or 0 >= self.chunk[1][1] or lo[1] >= self.chunk[2][1] ):
                    continue
                if ( hi[0] <  self.chunk[0][0] or ny < self.chunk[1][0] or hi[1] <  self.chunk[2][0] ):
                    continue

                # Read in proc's data if there is an overlap.
                
                this_x, this_y, this_z = numpy.loadtxt(coordfile, skiprows=2, unpack=True, usecols=(0,1,2))
                this_x = this_x.reshape((hi[0]-lo[0], ny, hi[1]-lo[1]), order='F')
                this_y = this_y.reshape((hi[0]-lo[0], ny, hi[1]-lo[1]), order='F')
                this_z = this_z.reshape((hi[0]-lo[0], ny, hi[1]-lo[1]), order='F')

                # Copy data into chunk arrays.
                
                x_c[ max(0,lo[0]-self.chunk[0][0]):min(self.chunk[0][1]-self.chunk[0][0],hi[0]-self.chunk[0][0]), 
                     max(0,   0 -self.chunk[1][0]):min(self.chunk[1][1]-self.chunk[1][0],  ny -self.chunk[1][0]),    
                     max(0,lo[1]-self.chunk[2][0]):min(self.chunk[2][1]-self.chunk[2][0],hi[1]-self.chunk[2][0]) ] = \
                this_x[ max(0,self.chunk[0][0]-lo[0]):min(hi[0]-lo[0],self.chunk[0][1]-lo[0]),
                        max(0,self.chunk[1][0]- 0   ):min(  ny -  0  ,self.chunk[1][1]- 0   ),
                        max(0,self.chunk[2][0]-lo[1]):min(hi[1]-lo[1],self.chunk[2][1]-lo[1]) ]

                y_c[ max(0,lo[0]-self.chunk[0][0]):min(self.chunk[0][1]-self.chunk[0][0],hi[0]-self.chunk[0][0]), 
                     max(0,   0 -self.chunk[1][0]):min(self.chunk[1][1]-self.chunk[1][0],  ny -self.chunk[1][0]),    
                     max(0,lo[1]-self.chunk[2][0]):min(self.chunk[2][1]-self.chunk[2][0],hi[1]-self.chunk[2][0]) ] = \
                this_y[ max(0,self.chunk[0][0]-lo[0]):min(hi[0]-lo[0],self.chunk[0][1]-lo[0]),
                        max(0,self.chunk[1][0]- 0   ):min(  ny -  0  ,self.chunk[1][1]- 0   ),
                        max(0,self.chunk[2][0]-lo[1]):min(hi[1]-lo[1],self.chunk[2][1]-lo[1]) ]

                z_c[ max(0,lo[0]-self.chunk[0][0]):min(self.chunk[0][1]-self.chunk[0][0],hi[0]-self.chunk[0][0]), 
                     max(0,   0 -self.chunk[1][0]):min(self.chunk[1][1]-self.chunk[1][0],  ny -self.chunk[1][0]),    
                     max(0,lo[1]-self.chunk[2][0]):min(self.chunk[2][1]-self.chunk[2][0],hi[1]-self.chunk[2][0]) ] = \
                this_z[ max(0,self.chunk[0][0]-lo[0]):min(hi[0]-lo[0],self.chunk[0][1]-lo[0]),
                        max(0,self.chunk[1][0]- 0   ):min(  ny -  0  ,self.chunk[1][1]- 0   ),
                        max(0,self.chunk[2][0]-lo[1]):min(hi[1]-lo[1],self.chunk[2][1]-lo[1]) ]

        return x_c, y_c, z_c
    
    
    def readData(self, var_names, data=None):
        """
        Method to read in the a chunk of the data for variables at current vizdump step.
        """
        
        # If a simple string is passed in, convert to a tuple.
        if isinstance(var_names, basestring):
            var_names = (var_names,)
        
        chunk_size = (self.chunk[0][1]-self.chunk[0][0], self.chunk[1][1]-self.chunk[1][0], self.chunk[2][1]-self.chunk[2][0])
        if data == None:
            _data = [ numpy.zeros( chunk_size ) for i in range(len(var_names)) ]
        else:
            _data = data
        
        ny = self._domain_size[1]
        
        for i in range(len(var_names)):
            var = var_names[i]
            v   = _data[i]
            
            ind = self.inds[var]
            
            for row in range(self.prow):
                for col in range(self.pcol):
                    filename = self.filename_prefix + ('%04d_px%04d_pz%04d.dat' % (self._step, row, col))
                    lo = self.pencil_lo[row,col]
                    hi = self.pencil_hi[row,col]
                    
                    # Skip this proc if it's lowest dimension is higher than max of chunk.
                    
                    if ( lo[0] >= self.chunk[0][1] or 0 >= self.chunk[1][1] or lo[1] >= self.chunk[2][1] ):
                        continue
                    if ( hi[0] <  self.chunk[0][0] or ny < self.chunk[1][0] or hi[1] <  self.chunk[2][0] ):
                        continue
                    
                    # Read in processor's data if there is an overlap.
                    
                    this_var = numpy.loadtxt(filename, skiprows=2, unpack=True, usecols=(ind,))
                    this_var = this_var.reshape((hi[0]-lo[0], ny, hi[1]-lo[1]), order='F')
                
                    # Copy data into chunk arrays.
                    
                    v[ max(0,lo[0]-self.chunk[0][0]):min(self.chunk[0][1]-self.chunk[0][0],hi[0]-self.chunk[0][0]), 
                       max(0,   0 -self.chunk[1][0]):min(self.chunk[1][1]-self.chunk[1][0],  ny -self.chunk[1][0]),    
                       max(0,lo[1]-self.chunk[2][0]):min(self.chunk[2][1]-self.chunk[2][0],hi[1]-self.chunk[2][0]) ] = \
                    this_var[ max(0,self.chunk[0][0]-lo[0]):min(hi[0]-lo[0],self.chunk[0][1]-lo[0]),
                              max(0,self.chunk[1][0]- 0   ):min(  ny -  0  ,self.chunk[1][1]- 0   ),
                              max(0,self.chunk[2][0]-lo[1]):min(hi[1]-lo[1],self.chunk[2][1]-lo[1]) ]
        
        if data == None:
            return tuple(_data)
    
    
BaseReader.register(WchrAsciiReader)

if __name__ == '__main__':
    print 'Subclass:', issubclass(WchrAsciiReader, BaseReader)
    print 'Instance:', isinstance(WchrAsciiReader("../tests/test_data_wchr_ascii/WCHR_"), BaseReader)

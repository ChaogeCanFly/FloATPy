import glob
import h5py
import numpy

from base_reader import BaseReader

class PadeopsReader(BaseReader):
    """
    Class to read in HDF5 data generated by PadeOps.
    """
    
    def __init__(self, filename_prefix, periodic_dimensions=(False,False,False)):
        """
        Constructor of the PadeOps reader class.
        """
        
        self.filename_prefix = filename_prefix
        vizfiles = glob.glob(self.filename_prefix + '[0-9]*.h5')
        
        self._steps = steps = []
        for vizfile in vizfiles:
            idx = vizfile.find('.h5')
            step = int(vizfile[idx-4:idx])
            if not (step in steps):
                steps.append(step)

        self._steps = sorted(self._steps)
            
        # Set the domain size in x, y and z directions respectively.
        vizfile = h5py.File(self.filename_prefix + 'coords.h5', 'r')
        self._domain_size = vizfile.attrs['GridSize']
        vizfile.close()
        
        # Set periodicity in each direction.
        self._periodic_dimensions = tuple(periodic_dimensions)

        # Step is set to 0 by default.
        self.step = 0
        # self._time = 0.
    
        # Set the default chunk to be the full domain.
        self.chunk = ( (0, self._domain_size[0]), (0, self._domain_size[1]), (0, self._domain_size[2]) )
    
    
    def setStep(self, step):
        """
        Update the metadata from the summary file in the data directory at a new time step.
        """
        
        assert (step in self._steps), "Step to read in is not available in the dataset."
        self._step = step

        vizfile = h5py.File(self.filename_prefix + '%04d.h5' %step, 'r')
        self._time = vizfile.attrs['Time'][0]
        vizfile.close()
    
    
    def getStep(self):
        return self._step
    
    
    step = property(getStep, setStep)
    
    
    def setSubDomain(self, lo_and_hi):
        """
        Set the sub-domain for reading coordinates and data.
        """
        
        # Check if lo and hi are within the domain bounds first!!!
        
        try:
            lo, hi = lo_and_hi
        except ValueError:
            raise ValueError("Pass an iterable with two items!")
        
        for i in range(3):
            if lo[i] < 0 or lo[i] > self._domain_size[i]:
                raise ValueError('Invalid indices in chunk. Cannot be < 0 or > domain size!')
            if hi[i] < 0 or hi[i] > self._domain_size[i]:
                raise ValueError('Invalid indices in chunk. Cannot be < 0 or > domain size!')
            if hi[i] < lo[i]:
                raise ValueError('Invalid indices in chunk. Upper bound cannot be smaller than lower bound!')
        
        # Now set the chunk to be used later.
        self.chunk = ( (lo[0], hi[0] + 1), (lo[1], hi[1] + 1), (lo[2], hi[2] + 1) )
    
    
    def getSubDomain(self):
        """
        Return two tuples containing the sub-domain used in this reader
        as a lower bound (lo) and upper bound (hi).
        """
        
        lo = (self.chunk[0][0], self.chunk[1][0], self.chunk[2][0])
        hi = (self.chunk[0][1] - 1, self.chunk[1][1] - 1, self.chunk[2][1] - 1)
        
        return lo, hi
    
    
    sub_domain = property(getSubDomain, setSubDomain)
    
    
    @property
    def domain_size(self):
        """
        Return a tuple containing the full domain size of this dataset.
        """
        
        return tuple(self._domain_size)
    
    
    @property
    def dimension(self):
        """
        Return the dimension of the domain.
        """
        
        return 3
    
    
    @property
    def periodic_dimensions(self):
        """
        Return a tuple indicating if data is periodic in each dimension.
        """
        
        return self._periodic_dimensions
    
    
    @property
    def time(self):
        """
        Return the simulation time at current time step.
        """
        
        return self._time
    
    
    @property
    def data_order(self):
        """
        Return the data order.
        """
        
        return 'F'
    
    
    @property
    def steps(self):
        """
        Return all of the steps.
        """
        
        return tuple(self._steps)
    
    
    def readCoordinates(self):
        """
        Method to read in the X, Y and Z coordinates of a chunk of index values.
        """
        
        chunk_size = (self.chunk[0][1]-self.chunk[0][0], self.chunk[1][1]-self.chunk[1][0], self.chunk[2][1]-self.chunk[2][0])

        vizfile = h5py.File(self.filename_prefix + 'coords.h5', 'r')

        # Read data in C contiguous order using h5py
        x_c = vizfile['X'][self.chunk[2][0]:self.chunk[2][1],\
                           self.chunk[1][0]:self.chunk[1][1],self.chunk[0][0]:self.chunk[0][1]]
        y_c = vizfile['Y'][self.chunk[2][0]:self.chunk[2][1],\
                           self.chunk[1][0]:self.chunk[1][1],self.chunk[0][0]:self.chunk[0][1]]
        z_c = vizfile['Z'][self.chunk[2][0]:self.chunk[2][1],\
                           self.chunk[1][0]:self.chunk[1][1],self.chunk[0][0]:self.chunk[0][1]]
        
        # Reshape data to F contiguous order without copying
        x_c = x_c.reshape( (chunk_size[0]*chunk_size[1]*chunk_size[2]) ).reshape( chunk_size, order='F' )
        y_c = y_c.reshape( (chunk_size[0]*chunk_size[1]*chunk_size[2]) ).reshape( chunk_size, order='F' )
        z_c = z_c.reshape( (chunk_size[0]*chunk_size[1]*chunk_size[2]) ).reshape( chunk_size, order='F' )

        if x_c.dtype != numpy.float64:
            x_c = x_c.astype(numpy.float64, casting='same_kind')
        if y_c.dtype != numpy.float64:
            y_c = y_c.astype(numpy.float64, casting='same_kind')
        if z_c.dtype != numpy.float64:
            z_c = z_c.astype(numpy.float64, casting='same_kind')

        vizfile.close()

        return x_c, y_c, z_c
    
    
    def readData(self, var_names, data=None):
        """
        Method to read in the a chunk of the data for variables at current vizdump step.
        """
        
        # If a simple string is passed in, convert to a tuple.
        if isinstance(var_names, basestring):
            var_names = (var_names,)
        
        chunk_size = (self.chunk[0][1]-self.chunk[0][0], self.chunk[1][1]-self.chunk[1][0], self.chunk[2][1]-self.chunk[2][0])
        if data == None:
            _data = [ numpy.zeros( chunk_size ) for i in range(len(var_names)) ]
        else:
            _data = data
        
        vizfile = h5py.File(self.filename_prefix + '%04d.h5' %self._step, 'r')
        
        for i in range(len(var_names)):
            var = var_names[i]

            # Read data in C contiguous order using h5py
            v = vizfile[var][self.chunk[2][0]:self.chunk[2][1],\
                             self.chunk[1][0]:self.chunk[1][1],self.chunk[0][0]:self.chunk[0][1]]
            # Reshape data to F contiguous order without copying
            _data[i] = v.reshape( (chunk_size[0]*chunk_size[1]*chunk_size[2]) ).reshape( chunk_size, order='F' )
            if _data[i].dtype != numpy.float64:
                _data[i] = _data[i].astype(numpy.float64, casting='same_kind')

        vizfile.close()
            
        if data == None:
            return tuple(_data)
    
    
BaseReader.register(PadeopsReader)

if __name__ == '__main__':
    print 'Subclass:', issubclass(PadeopsReader, BaseReader)
    print 'Instance:', isinstance(PadeopsReader("/home/akshays/Data/PadeOps/taylorgreen/N0064/taylorgreen.h5"), BaseReader)
